

print ("Calculate small world distance matrix")
library("igraph")
library("intergraph")
library("csound")
library("playitbyr")
minmax.scale<-function(v){
    max<-max(v)
    min<-min(v)
    print(max)
    print (min) 
    normalizeit<-function(x){
	return ((x-min)/(max-min))
    }
    
    return (sapply(v,normalizeit))
}
calculate.pairwiseDistance<-function(v){
    n<-length(v)
    m<-matrix(numeric(0),n,n)
    for(i in 1:n){
	for(j in 1:n){
	m[i,j]<-abs(v[i]-v[j])#manhattan distance
	} 
    }#i loop
    return(m)

}

##############################################Calculate distance of local graph measures
#g1,g2 is type of igraph
calculate.degree.dist<-function(g1,g2){
stand.len<-19
#maximal degree distribution can be achieved is 18, complement each degree distribution to length 19(0,18)
degdistr1<-degree.distribution(g1)
degdistr2<-degree.distribution(g2)

degdistr1<-rep(degdistr1,length.out=stand.len)
degdistr2<-rep(degdistr2,length.out=stand.len)
if(length(degdistr1)<stand.len){degdistr1[(len1+1):stand.len]<-0}
if(length(degdistr2)<stand.len){degdistr2[(len2+1):stand.len]<-0}


weight<-rep(1,length(degdistr1))

A<-cbind(weight,degdistr1)
B<-cbind(weight,degdistr2)
dist<-emd(A, B, dist="euclidean")

return(dist)
}#end function



#################################################






#######################################################################Calculate Small World Distance

igraph_db<-lapply(graph_db,asIgraph)
#average path length
apl_list<-lapply(igraph_db,function(x){return (average.path.length(graph=x,directed=F,unconnected=F))})
apl<-c(do.call("cbind",apl_list))
normalized_apl<-minmax.scale(apl)
normalized_apl_distance<-calculate.pairwiseDistance(normalized_apl)
#clustering coefficent
cc_list<-lapply(igraph_db,function(x){return(transitivity(x,type="localaverageundirected",isolates="zero"))})
cc<-c(do.call("cbind",cc_list))
normalized_cc<-minmax.scale(cc)
normalized_cc_distance<-calculate.pairwiseDistance(normalized_cc)
#degree distribution
dd_distance<-matrix(numeric(0),length(igraph_db),length(igraph_db))
for(i in 1:length(igraph_db)){
print(i)
for(j in i:length(igraph_db)){
dd_distance[i,j]<-dd_distance[j,i]<-calculate.degree.dist(igraph_db[[i]],igraph_db[[j]])
}#end j
}#end i

sw.dist.matrix<-as.dist((normalized_apl_distance+normalized_cc_distance+dd_distance)/2)
#######################################################################



print ("Clustering")
####################################### Clustering
library("fpc")
library("cluster")
set.seed(123)
#hierachical clustering
agn<-agnes(sw.dist.matrix,method="ward")
hh<-cutree(as.hclust(agn),h=8000)
#attach cluster column to db
db$cluster<-hh
#reconstruct time series information for each patient
sequence_db<-aggregate(db$cluster,by=list(db$ID),FUN=as.vector)

####Now the structure of the data is following
# id,  list(c(1,2,3,3,3,4,5))

#convert the 2 column to a string
convert.to.string<-function(x) return(paste(as.character(x[[1]]),collapse=""))
col_headings<-c("ID","Sequence")
names(sequence_db)<-col_headings

sequence_db["Sequence"]<-apply(sequence_db["Sequence"],MARGIN=c(1),FUN=convert.to.string)

#10 can not be identified from the string



